<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Are we Glean yet?</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
  <body>
    <h1>Are we Glean yet? <span id="percent"></span></h1>
    
    <h2>% Glean</h2>
    <div style="width: 80%; margin: auto;">
        <canvas id="percentGleanChart"></canvas>
    </div>

    <h2>Glean and Legacy telemetry probe count</h2>
    <div style="width: 80%; margin: auto;">
        <canvas id="evolutionChart"></canvas>
    </div>

    <h2>Legacy events burndown</h2>
    <div style="width: 80%; margin: auto;">
        <canvas id="eventsChart"></canvas>
    </div>

    <h2>Legacy scalars burndown</h2>
    <div style="width: 80%; margin: auto;">
        <canvas id="scalarsChart"></canvas>
    </div>

    <h2>Legacy histograms burndown</h2>
    <div style="width: 80%; margin: auto;">
        <canvas id="histogramsChart"></canvas>
    </div>
    
    <script>
      const CHART_COLORS = {
        red: 'rgb(255, 99, 132)',
        orange: 'rgb(255, 159, 64)',
        yellow: 'rgb(255, 205, 86)',
        green: 'rgb(75, 192, 192)',
        blue: 'rgb(54, 162, 235)',
        purple: 'rgb(153, 102, 255)',
        grey: 'rgb(201, 203, 207)'
      };
      
      // Data
      let buildids = [];
      let logs = [];

      // Percent chart
      let percentGleanOnly = [];
      let percentGleanWithMirror = [];
      let percentLegacyOnly = [];

      // Evolution chart
      let legacyOnly = [];
      let gleanWithMirror = [];
      let gleanOnly = [];

      let eventsWithoutMirror = [];
      let eventsWithMirror = [];

      let scalarsWithoutMirror = [];
      let scalarsWithMirror = [];
      
      let histogramsWithoutMirror = [];
      let histogramsWithMirror = [];

      fetch("./data.json").then(async response => {
        let lines = (await response.text()).split("\n");
        for (let line of lines) {
          if (!line || line.startsWith("stderr: warning: Watchman unavailable")) {
            continue;
          }
          let {buildid, data, log} = JSON.parse(line);
          buildids.push(buildid.slice(0, 10));
          let legOnly = data.legacyOnlyEvents + data.legacyOnlyHistograms + data.legacyOnlyScalars;
          legacyOnly.push(legOnly);
          gleanOnly.push(data.metricsWithoutUseCounters - data.metricsWithTelemetryMirror);
          gleanWithMirror.push(data.metricsWithTelemetryMirror);
          logs.push(log);
          eventsWithoutMirror.push(data.legacyOnlyEvents);
          eventsWithMirror.push(data.events - data.legacyOnlyEvents);
          scalarsWithoutMirror.push(data.legacyOnlyScalars);
          scalarsWithMirror.push(data.scalars - data.legacyOnlyScalars);
          histogramsWithoutMirror.push(data.legacyOnlyHistograms);
          histogramsWithMirror.push(data.histograms - data.legacyOnlyHistograms);

          let toPercent = val => val / (legOnly + data.metricsWithoutUseCounters) * 100;
          percentGleanOnly.push(toPercent(data.metricsWithoutUseCounters - data.metricsWithTelemetryMirror));
          percentGleanWithMirror.push(toPercent(data.metricsWithTelemetryMirror));
          percentLegacyOnly.push(toPercent(legOnly));
        }

        let percent = percentGleanOnly.at(-1) + percentGleanWithMirror.at(-1);
        let percentText = percent < 100 ? `No, ${percent.toFixed(1)}% Glean` : "Yes!";
        document.getElementById("percent").textContent = percentText;
        document.title += " " + percentText;

        // Create the chart
        const footer = (tooltipItems) => {
          return logs[tooltipItems[0].dataIndex];
        };

        let getCtx = id => document.getElementById(id).getContext('2d');
        let dataset = (data, label, color) => ({label, data, borderColor: CHART_COLORS[color]});
        new Chart(getCtx("percentGleanChart"), {
          type: 'line',
          data: {
            labels: buildids,  // Build IDs are used as labels (time)
            datasets: [
              dataset(percentGleanOnly, "Glean only", "green"),
              dataset(percentGleanWithMirror, "Glean mirroring to legacy Telemetry", "blue"),
              dataset(percentLegacyOnly, "Legacy Telemetry", "red"),
            ]
          },
          options: {
            animation: false,
            plugins: { tooltip: { callbacks: { footer: footer }}},
            scales: {
              x: { title: { display: true, text: 'Nightly build ID (Time)' }},
              y: { stacked: true, beginAtZero: true, max: 100 }
            }
          }
        });

        new Chart(getCtx("evolutionChart"), {
          type: 'line',
          data: {
            labels: buildids,  // Build IDs are used as labels (time)
            datasets: [
              dataset(gleanOnly, "Glean only", "green"),
              dataset(gleanWithMirror, "Glean mirroring to legacy Telemetry", "blue"),
              dataset(legacyOnly, "Legacy Telemetry", "red"),
            ]
          },
          options: {
            plugins: { tooltip: { callbacks: { footer: footer }}},
            scales: {
              x: { title: { display: true, text: 'Nightly build ID (Time)' }},
              y: { beginAtZero: true, title: { display: true, text: 'Count' }}
            }
          }
        });

        new Chart(getCtx("eventsChart"), {
          type: 'line',
          data: {
            labels: buildids,  // Build IDs are used as labels (time)
            datasets: [
              dataset(eventsWithMirror, "Events mirrored from Glean", "blue"),
              dataset(eventsWithoutMirror, "Legacy events not mirrored", "red"),
            ]
          },
          options: {
            plugins: { tooltip: { callbacks: { footer: footer }}},
            scales: {
              x: { title: { display: true, text: 'Nightly build ID (Time)' }},
              y: { beginAtZero: true, title: { display: true, text: 'Count' }}
            }
          }
        });
        new Chart(getCtx("scalarsChart"), {
          type: 'line',
          data: {
            labels: buildids,  // Build IDs are used as labels (time)
            datasets: [
              dataset(scalarsWithMirror, "Scalars mirrored from Glean", "blue"),
              dataset(scalarsWithoutMirror, "Legacy scalars not mirrored", "red"),
            ]
          },
          options: {
            plugins: { tooltip: { callbacks: { footer: footer }}},
            scales: {
              x: { title: { display: true, text: 'Nightly build ID (Time)' }},
              y: { beginAtZero: true, title: { display: true, text: 'Count' }}
            }
          }
        });
        new Chart(getCtx("histogramsChart"), {
          type: 'line',
          data: {
            labels: buildids,  // Build IDs are used as labels (time)
            datasets: [
              dataset(histogramsWithMirror, "Histograms mirrored from Glean", "blue"),
              dataset(histogramsWithoutMirror, "Legacy histograms not mirrored", "red"),
            ]
          },
          options: {
            plugins: { tooltip: { callbacks: { footer: footer }}},
            scales: {
              x: { title: { display: true, text: 'Nightly build ID (Time)' }},
              y: { beginAtZero: true, title: { display: true, text: 'Count' }}
            }
          }
        });
      });
    </script>

    <h2>Notes</h2>
    <ul>
      <li>Use counters were ignored in the previous charts as there are thousands of them generated by scripts. Counting them would over-report them in the Glean percentages. Not counting them under-reports the effort that went into migrating them.</li>
      <li>The telemetry evenvironment isn't accounted for in the Glean percentage, because the migration plan for it isn't refined enough to be able to quantify how many metrics the current legacy Telemetry environment represents.</li>
    </ul>
</body>
</html>
